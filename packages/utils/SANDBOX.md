# SafeSandbox - Secure PHP Code Execution

SafeSandbox provides a secure environment for executing untrusted or LLM-generated PHP code with comprehensive security controls and resource limits.

## Table of Contents

- [Overview](#overview)
- [Use Cases](#use-cases)
- [Quick Start](#quick-start)
- [API Reference](#api-reference)
- [Security Features](#security-features)
- [Drivers](#drivers)
- [Internal Design](#internal-design)
- [Testing](#testing)
- [Best Practices](#best-practices)

---

## Overview

SafeSandbox is designed to safely execute PHP code that may contain bugs, infinite loops, or accidental resource exhaustion. It provides multiple isolation drivers with defense-in-depth security.

### Key Features

- **Process Isolation** - Runs code in separate process groups
- **Resource Limits** - Memory, timeout, and output size controls
- **Function Restrictions** - Disables dangerous PHP functions
- **File System Isolation** - Restricts file access via open_basedir
- **Network Control** - Network access disabled by default
- **Environment Security** - Filters dangerous environment variables
- **Path Validation** - Prevents access to sensitive system paths

### Threat Model

SafeSandbox is designed for **LLM-generated code for tool orchestration**:

- ✅ Protects against accidental disasters (file deletion, data overwrites)
- ✅ Prevents resource exhaustion (infinite loops, memory exhaustion)
- ✅ Blocks common programming mistakes that could be dangerous
- ⚠️ NOT designed for malicious adversarial attacks
- ⚠️ NOT a replacement for proper security boundaries

---

## Use Cases

### 1. LLM Tool Orchestration

Execute code generated by language models to interact with your application:

```php
use Cognesy\Addons\SafeSandbox\SafeSandbox;
use Cognesy\Addons\SafeSandbox\Config\SandboxPolicy;

// Execute LLM-generated code safely
$policy = SandboxPolicy::in('/tmp/sandbox')
    ->withTimeout(5)
    ->withMemory('64M');

$sandbox = SafeSandbox::phpIsolated($policy);

$llmGeneratedCode = '
    $data = ["name" => "Alice", "age" => 30];
    echo json_encode($data);
';

$result = $sandbox->execute($llmGeneratedCode);

if ($result->isSuccess()) {
    $output = $result->unwrap()->getOutput();
    echo "Result: $output\n";
}
```

### 2. Code Playground

Execute user-submitted code snippets safely:

```php
$policy = SandboxPolicy::in(sys_get_temp_dir())
    ->withTimeout(10)
    ->withMemory('128M')
    ->withReadablePaths('/path/to/data');

$sandbox = SafeSandbox::phpIsolated($policy);
$result = $sandbox->execute($userCode);

if ($result->isFailure()) {
    echo "Error: " . $result->error()->getMessage();
}
```

### 3. Plugin System

Execute third-party plugins in isolated environment:

```php
$policy = SandboxPolicy::in('/tmp/plugins')
    ->withTimeout(30)
    ->withMemory('256M')
    ->withEnv(['PLUGIN_API_KEY' => $apiKey]);

$sandbox = SafeSandbox::phpIsolated($policy);
$result = $sandbox->execute($pluginCode);
```

---

## Quick Start

### Installation

```bash
composer require cognesy/instructor-php
```

### Basic Example

```php
<?php

use Cognesy\Addons\SafeSandbox\SafeSandbox;
use Cognesy\Addons\SafeSandbox\Config\SandboxPolicy;

// 1. Create a policy
$policy = SandboxPolicy::in(sys_get_temp_dir())
    ->withTimeout(5)
    ->withMemory('64M');

// 2. Create sandbox with driver
$sandbox = SafeSandbox::phpIsolated($policy);

// 3. Execute code
$result = $sandbox->execute('
    echo "Hello from sandbox!";
');

// 4. Handle result
if ($result->isSuccess()) {
    $sandboxResult = $result->unwrap();
    echo $sandboxResult->getOutput(); // "Hello from sandbox!"
} else {
    echo "Error: " . $result->error()->getMessage();
}
```

---

## API Reference

### SandboxPolicy

Immutable value object that defines sandbox behavior.

#### Static Constructor

```php
SandboxPolicy::in(string $baseDir): self
```

Creates a new policy with the specified base directory.

**Example:**
```php
$policy = SandboxPolicy::in('/tmp/sandbox');
```

#### Configuration Methods

All configuration methods return a new instance (immutable):

```php
// Set execution timeout (minimum 1 second)
withTimeout(int $seconds): self

// Set memory limit (validates and clamps to 1G max)
withMemory(string $limit): self

// Add readable paths (outside working directory)
withReadablePaths(string ...$paths): self

// Set environment variables (dangerous vars filtered)
withEnv(array $env): self

// Enable network access (disabled by default)
withNetworkAccess(): self

// Add additional disabled functions
withAdditionalDisabledFunctions(string ...$functions): self
```

**Example:**
```php
$policy = SandboxPolicy::in('/tmp/sandbox')
    ->withTimeout(10)
    ->withMemory('128M')
    ->withReadablePaths('/data/allowed', '/data/public')
    ->withEnv(['API_KEY' => 'safe-value'])
    ->withNetworkAccess();
```

#### Getter Methods

```php
baseDir(): string
timeoutSeconds(): int
memoryLimit(): string
readablePaths(): array
env(): array
networkEnabled(): bool
disabledFunctions(): array
```

#### Default Disabled Functions

The following functions are disabled by default:

**Process Execution:**
- `exec`, `system`, `shell_exec`, `passthru`
- `proc_open`, `proc_terminate`, `proc_get_status`, `popen`

**Network:**
- `curl_exec`, `curl_multi_exec`
- `socket_create`, `fsockopen`, `pfsockopen`, `stream_socket_client`

**Process Control (PCNTL):**
- `pcntl_alarm`, `pcntl_fork`, `pcntl_exec`, `pcntl_signal`
- `pcntl_wait`, `pcntl_waitpid`, `pcntl_async_signals`

**POSIX:**
- `posix_kill`, `posix_mkfifo`, `posix_setuid`, `posix_setgid`
- `posix_uname`, `posix_getpwuid`, `posix_getgrgid`

**File System:**
- `link`, `symlink`, `chroot`, `chgrp`, `chown`

**Configuration:**
- `ini_set`, `ini_alter`, `putenv`, `getenv`, `dl`

**Other:**
- `parse_ini_file`, `show_source`, `mail`

---

### SafeSandbox

Main entry point for executing sandboxed code.

#### Static Factory Methods

```php
// PHP-based isolation (recommended)
SafeSandbox::phpIsolated(SandboxPolicy $policy): self

// Container-based isolation
SafeSandbox::docker(SandboxPolicy $policy, ?string $image = null): self
SafeSandbox::podman(SandboxPolicy $policy, ?string $image = null): self

// Namespace-based isolation (Linux)
SafeSandbox::firejail(SandboxPolicy $policy): self
SafeSandbox::bubblewrap(SandboxPolicy $policy): self
```

**Example:**
```php
$sandbox = SafeSandbox::phpIsolated($policy);
```

#### Execution

```php
execute(string $phpCode): Result
```

Executes PHP code and returns a `Result<SandboxResult>` monad.

**Parameters:**
- `$phpCode` - PHP code to execute (without opening `<?php` tag)

**Returns:** `Result<SandboxResult, Throwable>`
- `Result::success(SandboxResult)` - Execution completed
- `Result::failure(Throwable)` - Sandbox initialization or execution failed

**Example:**
```php
$result = $sandbox->execute('
    $data = ["hello" => "world"];
    echo json_encode($data);
');

if ($result->isSuccess()) {
    $exec = $result->unwrap();
    echo $exec->getOutput(); // {"hello":"world"}
} else {
    // Handle initialization/execution error
    error_log($result->error()->getMessage());
}
```

#### Policy Access

```php
policy(): SandboxPolicy
```

Returns the current policy configuration.

---

### SandboxResult

Contains the results of sandbox execution.

#### Methods

```php
// Output streams
getOutput(): string          // stdout content
getErrorOutput(): string     // stderr content
getCombinedOutput(): string  // stdout + stderr

// Execution details
getExitCode(): int          // Process exit code
getExecutionTime(): float   // Wall time in seconds
getMemoryUsed(): int        // Peak memory in bytes

// Status checks
isSuccess(): bool           // Exit code 0 and not timed out
isTimedOut(): bool         // Execution exceeded timeout

// Serialization
toArray(): array           // Convert to array
```

**Example:**
```php
$result = $sandbox->execute($code);

if ($result->isSuccess()) {
    $exec = $result->unwrap();

    echo "Output: " . $exec->getOutput() . "\n";
    echo "Errors: " . $exec->getErrorOutput() . "\n";
    echo "Exit code: " . $exec->getExitCode() . "\n";
    echo "Time: " . $exec->getExecutionTime() . "s\n";
    echo "Memory: " . round($exec->getMemoryUsed() / 1024 / 1024, 2) . "MB\n";

    if ($exec->isTimedOut()) {
        echo "Warning: Execution timed out\n";
    }
}
```

---

## Security Features

### 1. Process Isolation

**How it works:**
- Uses `setsid` to create new session/process group
- Timeout enforcement kills entire process group (SIGTERM → SIGKILL)
- Prevents zombie processes and fork bombs

**Configuration:**
```php
$policy = SandboxPolicy::in('/tmp')
    ->withTimeout(5); // 5 second timeout
```

### 2. Memory Limits

**How it works:**
- Validates memory limit format (e.g., "128M", "1G")
- Clamps excessive limits to maximum 1G
- Rejects unbounded limit (-1)
- Enforced via PHP INI setting

**Configuration:**
```php
$policy = SandboxPolicy::in('/tmp')
    ->withMemory('128M'); // 128 megabytes
```

**Memory limit validation:**
- Accepts: `64M`, `128M`, `256M`, `512M`, `1G`
- Rejects: `-1`, `abc`, `2G` (clamped to 1G)

### 3. Function Restrictions

**How it works:**
- Uses PHP's `disable_functions` INI directive
- 23 dangerous functions disabled by default
- Can add additional restrictions

**Configuration:**
```php
$policy = SandboxPolicy::in('/tmp')
    ->withAdditionalDisabledFunctions('file_get_contents', 'file_put_contents');
```

### 4. File System Isolation

**How it works:**
- Sandbox creates isolated working directory
- `open_basedir` restricts access to working directory
- Additional readable paths can be added
- Forbidden paths blocked (e.g., /etc, /root, /proc, /sys)

**Configuration:**
```php
$policy = SandboxPolicy::in('/tmp/sandbox')
    ->withReadablePaths('/data/public', '/config/readonly');
```

**Forbidden paths:**
- `/etc`, `/root`, `/proc`, `/sys`, `/boot`
- `/var/spool/cron`, `/var/log`, `/var/mail`
- `~/.ssh`, `/root/.ssh`

### 5. Environment Security

**How it works:**
- Clean environment with only HOME and PATH
- Dangerous variables filtered out
- User-provided variables validated

**Configuration:**
```php
$policy = SandboxPolicy::in('/tmp')
    ->withEnv(['SAFE_VAR' => 'value']);
```

**Filtered environment variables:**
- Library injection: `LD_PRELOAD`, `LD_LIBRARY_PATH`, `DYLD_INSERT_LIBRARIES`
- PHP configuration: `PHP_INI_SCAN_DIR`, `PHPRC`
- Temporary paths: `TMPDIR`, `TEMP`, `TMP`
- Cloud credentials: `AWS_*`, `GOOGLE_*`, `AZURE_*`
- Language-specific: `GEM_*`, `NODE_OPTIONS`, `NPM_*`, `PYTHON*`

### 6. Network Control

**How it works:**
- Network disabled by default
- Must explicitly enable with `withNetworkAccess()`
- Socket functions disabled in function list

**Configuration:**
```php
$policy = SandboxPolicy::in('/tmp')
    ->withNetworkAccess(); // Enable networking
```

### 7. Output Size Limits

**How it works:**
- Stdout and stderr capped at 1MB each
- Prevents memory exhaustion from excessive output
- Old output discarded when limit reached

### 8. PHP INI Hardening

**Automatic hardening:**
- Uses `php -n` to ignore system INI files
- `allow_url_fopen=0` - Blocks URL file access
- `allow_url_include=0` - Blocks URL includes
- `expose_php=0` - Hides PHP version
- `enable_dl=0` - Disables extension loading
- `zend.assertions=-1` - Disables assertions
- `phar.readonly=1` - Prevents PHAR modification
- `phar.require_hash=1` - Requires PHAR signatures

---

## Drivers

SafeSandbox supports multiple isolation drivers with different security/complexity tradeoffs.

### PHP Isolated (Recommended)

Pure PHP implementation using process isolation and security features.

**Pros:**
- ✅ No external dependencies
- ✅ Works on all platforms with PHP
- ✅ Comprehensive security features
- ✅ Well-tested and production-ready

**Cons:**
- ⚠️ Less isolation than containers
- ⚠️ Shared kernel with host

**Usage:**
```php
$sandbox = SafeSandbox::phpIsolated($policy);
```

**Requirements:**
- PHP 8.2+
- `setsid` command (optional, for process group isolation)
- POSIX extension (optional, for signal handling)

### Docker

Container-based isolation using Docker.

**Pros:**
- ✅ Strong isolation
- ✅ Separate filesystem
- ✅ Container security features

**Cons:**
- ⚠️ Requires Docker daemon
- ⚠️ Higher overhead
- ⚠️ More complex setup

**Usage:**
```php
$sandbox = SafeSandbox::docker($policy, 'php:8.2-cli');
```

**Requirements:**
- Docker installed and running
- User has Docker permissions
- PHP Docker image available

### Podman

Container-based isolation using Podman (rootless).

**Pros:**
- ✅ Strong isolation
- ✅ Rootless containers
- ✅ Docker-compatible

**Cons:**
- ⚠️ Requires Podman
- ⚠️ Higher overhead

**Usage:**
```php
$sandbox = SafeSandbox::podman($policy, 'php:8.2-cli');
```

**Requirements:**
- Podman installed
- PHP container image available

### Firejail (Linux)

Namespace-based isolation using Firejail.

**Pros:**
- ✅ Good isolation
- ✅ Lower overhead than containers
- ✅ Seccomp filters

**Cons:**
- ⚠️ Linux only
- ⚠️ Requires Firejail installation
- ⚠️ Less tested

**Usage:**
```php
$sandbox = SafeSandbox::firejail($policy);
```

**Requirements:**
- Linux with Firejail installed
- User has permissions to run Firejail

### Bubblewrap (Linux)

Namespace-based isolation using Bubblewrap.

**Pros:**
- ✅ Good isolation
- ✅ Unprivileged operation
- ✅ Lightweight

**Cons:**
- ⚠️ Linux only
- ⚠️ Requires Bubblewrap installation
- ⚠️ Less tested

**Usage:**
```php
$sandbox = SafeSandbox::bubblewrap($policy);
```

**Requirements:**
- Linux with Bubblewrap (bwrap) installed

### Driver Comparison

| Driver | Isolation | Overhead | Platform | Status |
|--------|-----------|----------|----------|--------|
| PHP Isolated | Medium | Low | All | ✅ Production |
| Docker | High | High | All | ⚠️ Experimental |
| Podman | High | High | All | ⚠️ Experimental |
| Firejail | High | Medium | Linux | ⚠️ Experimental |
| Bubblewrap | High | Medium | Linux | ⚠️ Experimental |

**Recommendation:** Use `phpIsolated` for most use cases. Consider containers for stronger isolation requirements.

---

## Internal Design

### Architecture

```
SafeSandbox (Facade)
    ↓
SandboxDriver (Interface)
    ↓
PhpIsolatedDriver (Implementation)
    ↓
┌─────────────────────────────────┐
│ 1. createWorkingDirectory()     │
│    - Validate base directory    │
│    - Check forbidden paths      │
│    - Create temp directory      │
└─────────────────────────────────┘
    ↓
┌─────────────────────────────────┐
│ 2. writeScript()                │
│    - Wrap user code             │
│    - Add error reporting        │
│    - Add memory tracking        │
└─────────────────────────────────┘
    ↓
┌─────────────────────────────────┐
│ 3. buildCommand()               │
│    - php -n (ignore system INI) │
│    - disable_functions          │
│    - open_basedir               │
│    - memory_limit               │
│    - INI hardening              │
└─────────────────────────────────┘
    ↓
┌─────────────────────────────────┐
│ 4. buildEnv()                   │
│    - Filter dangerous vars      │
│    - Set HOME and PATH          │
│    - Add user variables         │
└─────────────────────────────────┘
    ↓
┌─────────────────────────────────┐
│ 5. runProcess()                 │
│    - Start with setsid          │
│    - Non-blocking I/O           │
│    - Monitor timeout            │
│    - Kill process group         │
│    - Capture output             │
└─────────────────────────────────┘
    ↓
┌─────────────────────────────────┐
│ 6. Cleanup                      │
│    - Remove script              │
│    - Remove working directory   │
└─────────────────────────────────┘
    ↓
Return Result<SandboxResult>
```

### Code Wrapping

User code is wrapped with setup and teardown:

```php
<?php
declare(strict_types=1);
error_reporting(E_ALL);
set_time_limit(5);
register_shutdown_function(function(){
    fwrite(STDERR, '__PEAK__:' . memory_get_peak_usage(true));
});

// USER CODE HERE

```

This allows:
- Strict type checking
- Full error reporting
- Timeout enforcement
- Memory peak tracking

### Process Management

```php
// 1. Start process with setsid
$setsid = '/usr/bin/setsid';
$cmd = [$setsid, '--', 'php', '-n', ...];
$proc = proc_open($cmd, $descriptors, $pipes, $cwd, $env);

// 2. Monitor execution
while (true) {
    $status = proc_get_status($proc);

    // Check timeout
    if (microtime(true) >= $deadline) {
        // Kill process group (negative PID)
        posix_kill(-$pid, SIGTERM);
        usleep(100_000);
        posix_kill(-$pid, SIGKILL);
        break;
    }

    // Read output (non-blocking)
    stream_select($pipes, ...);

    if (!$status['running']) {
        break;
    }
}
```

### Path Validation

```php
private function validatePath(string $path): bool {
    // Canonicalize path
    $real = realpath($path);

    // Check if path resolves
    if ($real === false) {
        return false; // Path doesn't exist
    }

    // Check against forbidden patterns
    foreach (self::FORBIDDEN_PATHS as $pattern) {
        if (fnmatch($pattern, $real)) {
            throw new RuntimeException('Forbidden path');
        }
    }

    return true;
}
```

### Memory Limit Validation

```php
private static function normalizeMemoryLimit(string $limit): string {
    // Reject unbounded
    if ($limit === '-1') {
        throw new InvalidArgumentException('Unbounded not allowed');
    }

    // Validate format
    if (!preg_match('/^\d+(K|M|G)?$/', $limit)) {
        throw new InvalidArgumentException('Invalid format');
    }

    // Parse to bytes
    $bytes = $this->parseMemoryLimit($limit);

    // Clamp to 1G
    if ($bytes > 1073741824) {
        return '1G';
    }

    return $limit;
}
```

---

## Testing

### Running Tests

```bash
# All SafeSandbox tests
vendor/bin/pest packages/addons/tests/Integration/SafeSandbox*.php

# Security tests only
vendor/bin/pest packages/addons/tests/Integration/SafeSandboxSecurityTest.php

# Functional tests only
vendor/bin/pest packages/addons/tests/Integration/SafeSandboxFunctionalTest.php

# Specific test group
vendor/bin/pest --filter="Fork Bomb"
vendor/bin/pest --filter="LLM Context"
```

### Test Coverage

**Security Tests (45 tests):**
- Fork bomb prevention
- Symlink and path traversal
- Command execution blocking
- Environment variable filtering
- Memory limit enforcement
- Timeout enforcement
- Code injection prevention
- Network access control
- Output size limits
- File system restrictions
- Base directory validation
- POSIX function blocking
- LLM context scenarios

**Functional Tests (33 tests):**
- Basic execution
- Policy configuration
- File operations
- Data processing
- Memory tracking
- Error handling
- Timeout behavior
- Multiple executions
- Policy immutability
- Result monad

### Test Results

```
Tests:    79 passed (100%)
Duration: ~11 seconds
Status:   ✅ Production Ready
```

---

## Best Practices

### 1. Choose Appropriate Timeout

```php
// Short tasks (data processing)
$policy = $policy->withTimeout(5);

// Medium tasks (API calls, file operations)
$policy = $policy->withTimeout(30);

// Long tasks (batch processing)
$policy = $policy->withTimeout(120);
```

### 2. Set Memory Based on Task

```php
// Simple calculations
$policy = $policy->withMemory('64M');

// JSON processing, small datasets
$policy = $policy->withMemory('128M');

// Large datasets, complex operations
$policy = $policy->withMemory('512M');
```

### 3. Use Result Monad Pattern

```php
$result = $sandbox->execute($code);

// Always check success
if ($result->isSuccess()) {
    $exec = $result->unwrap();

    // Check if timed out
    if ($exec->isTimedOut()) {
        // Handle timeout
    }

    // Process output
    $output = $exec->getOutput();
} else {
    // Handle initialization/execution failure
    $error = $result->error();
    error_log("Sandbox error: " . $error->getMessage());
}
```

### 4. Handle Timeouts Gracefully

```php
$exec = $result->unwrap();

if ($exec->isTimedOut()) {
    // Timeout is indicated by:
    // - isTimedOut() returns true
    // - Exit code is 124
    // - Error output contains __TIMEOUT__ marker

    echo "Code execution exceeded timeout of {$policy->timeoutSeconds()}s\n";
    echo "Consider optimizing the code or increasing timeout\n";
}
```

### 5. Validate User Input

```php
// Validate code length
if (strlen($userCode) > 10000) {
    throw new InvalidArgumentException('Code too long');
}

// Check for obvious issues
if (preg_match('/while\s*\(\s*true\s*\)/', $userCode)) {
    // Warn about potential infinite loop
}

// Then execute
$result = $sandbox->execute($userCode);
```

### 6. Provide Readable Paths Carefully

```php
// ✅ Good: Specific, read-only data
$policy = $policy->withReadablePaths('/data/public/readonly');

// ⚠️ Risky: Entire home directory
$policy = $policy->withReadablePaths('/home/user');

// ❌ Bad: Sensitive system directories (will be rejected)
$policy = $policy->withReadablePaths('/etc'); // Throws exception
```

### 7. Log Execution Details

```php
$result = $sandbox->execute($code);

if ($result->isSuccess()) {
    $exec = $result->unwrap();

    // Log for monitoring
    error_log(sprintf(
        'Sandbox execution: time=%.3fs memory=%dMB exit=%d',
        $exec->getExecutionTime(),
        round($exec->getMemoryUsed() / 1024 / 1024, 2),
        $exec->getExitCode()
    ));
}
```

### 8. Reuse Sandbox Instances

```php
// ✅ Good: Reuse sandbox for multiple executions
$sandbox = SafeSandbox::phpIsolated($policy);

foreach ($codeSnippets as $code) {
    $result = $sandbox->execute($code);
    // Process result...
}
```

### 9. Use Specific Error Messages

```php
if ($result->isFailure()) {
    $error = $result->error();

    if (str_contains($error->getMessage(), 'Forbidden baseDir')) {
        echo "Invalid working directory configuration\n";
    } elseif (str_contains($error->getMessage(), 'invalid or not writable')) {
        echo "Working directory not accessible\n";
    } else {
        echo "Sandbox initialization failed: " . $error->getMessage() . "\n";
    }
}
```

### 10. Test with LLM Output Patterns

```php
// Test common LLM mistakes
$testCases = [
    // Well-intentioned but buggy
    'while ($x > 0) { $x++; }', // Infinite loop

    // Wrong file paths
    'file_get_contents("/nonexistent/file.txt");',

    // Excessive memory
    '$arr = array_fill(0, 10000000, "data");',
];

foreach ($testCases as $code) {
    $result = $sandbox->execute($code);
    // Verify handling...
}
```

---

## FAQ

### Q: Is SafeSandbox production-ready?

**A:** Yes, the `phpIsolated` driver is production-ready for LLM tool orchestration. It has comprehensive test coverage (79 tests, 100% pass rate) and all security features are verified working.

### Q: Can SafeSandbox protect against malicious attacks?

**A:** SafeSandbox is designed for **accidental disasters**, not adversarial attacks. It protects against:
- ✅ LLM-generated code with bugs or infinite loops
- ✅ Accidental file deletion or data overwrites
- ✅ Resource exhaustion from programming mistakes

It does NOT protect against:
- ❌ Sophisticated adversarial attacks
- ❌ Kernel exploits or privilege escalation
- ❌ Timing attacks or side channels

### Q: What's the performance overhead?

**A:** The `phpIsolated` driver has minimal overhead:
- Process startup: ~10-50ms
- Memory: +10-20MB for isolation
- CPU: Minimal (process management)

Container drivers have higher overhead:
- Docker/Podman: 100-500ms startup
- More memory for container runtime

### Q: Can I use SafeSandbox with async code?

**A:** No, SafeSandbox executes code synchronously in a subprocess. For async execution:
- Use a job queue (e.g., Laravel Queues, Symfony Messenger)
- Run SafeSandbox in queue workers
- Aggregate results when jobs complete

### Q: How do I debug code running in the sandbox?

**A:** Check the error output and exit code:

```php
$result = $sandbox->execute($code);
$exec = $result->unwrap();

echo "Exit code: " . $exec->getExitCode() . "\n";
echo "Stdout: " . $exec->getOutput() . "\n";
echo "Stderr: " . $exec->getErrorOutput() . "\n";
```

For development, temporarily enable more verbose error output in your code.

### Q: Can I install Composer packages in the sandbox?

**A:** No, the sandbox has no network access or file write permissions outside the working directory. If you need packages:
- Pre-install them in the base PHP installation
- Mount a vendor directory as a readable path
- Use container drivers with pre-built images

### Q: What happens if code creates files?

**A:** Files are created in the isolated working directory and deleted after execution:

```php
$code = '
    file_put_contents("test.txt", "content");
    echo file_get_contents("test.txt");
';

$result = $sandbox->execute($code);
// Output: "content"
// test.txt is deleted after execution
```

To persist files, use readable paths:

```php
$policy = $policy->withReadablePaths('/data/persistent');

$code = '
    file_put_contents("/data/persistent/output.txt", "content");
';
```

### Q: How do I pass data to the sandbox?

**A:** Embed data in the code string:

```php
$data = ['name' => 'Alice', 'age' => 30];
$json = json_encode($data);

$code = "
    \$input = json_decode('$json', true);
    echo \$input['name'];
";

$result = $sandbox->execute($code);
```

Or use environment variables:

```php
$policy = $policy->withEnv(['INPUT_DATA' => json_encode($data)]);

$code = '
    $input = json_decode($_ENV["INPUT_DATA"] ?? "{}", true);
    echo $input["name"];
';
```

### Q: Can I use the sandbox for long-running processes?

**A:** No, SafeSandbox is designed for short-lived tasks (seconds to minutes). For long-running processes:
- Break work into smaller chunks
- Use a job queue with multiple workers
- Consider alternative isolation strategies

---

## License

Part of the Instructor for PHP package.

## Contributing

See the main project CONTRIBUTOR_GUIDE.md for contribution guidelines.

## Support

- GitHub Issues: https://github.com/cognesy/instructor-php/issues
- Documentation: https://github.com/cognesy/instructor-php

---

**Status:** ✅ Production Ready for LLM Tool Orchestration
