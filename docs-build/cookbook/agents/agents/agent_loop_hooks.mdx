---
title: 'Agent Lifecycle Hooks'
docname: 'agent_loop_hooks'
order: 5
---

## Overview

Hooks intercept agent lifecycle events to observe or modify state. Each hook receives
a `HookContext` and returns a (potentially modified) `HookContext`. Hooks can:

- **Observe**: Log events, collect metrics without changing state
- **Modify**: Inject metadata, adjust system prompts, transform messages
- **Block**: Prevent tool execution (for `BeforeToolUse` hooks)

Key concepts:
- `CallableHook`: Wraps a closure as a `HookInterface`
- `HookTriggers`: Specifies when the hook fires (e.g., `beforeStep()`, `afterStep()`)
- `HookContext`: Carries `AgentState`, tool call info, and trigger type
- `addHook()`: Registers hooks on `AgentBuilder` with priority ordering

## Example

```php
<?php
require 'examples/boot.php';

use Cognesy\Agents\Builder\AgentBuilder;use Cognesy\Agents\Capabilities\Bash\UseBash;use Cognesy\Agents\Data\AgentState;use Cognesy\Agents\Hook\Collections\HookTriggers;use Cognesy\Agents\Hook\Data\HookContext;use Cognesy\Agents\Hook\Hooks\CallableHook;

// Track timing data
$timings = [];

$agent = AgentBuilder::base()
    ->withCapability(new UseBash())
    ->withMaxSteps(5)

    // Hook 1: Before each step — inject timing metadata
    ->addHook(
        hook: new CallableHook(function (HookContext $ctx) use (&$timings): HookContext {
            $step = $ctx->state()->stepCount() + 1;
            $timings[$step] = microtime(true);
            echo "[BeforeStep] Step {$step} starting\n";
            return $ctx->withState(
                $ctx->state()->withMetadata('step_started_at', microtime(true))
            );
        }),
        triggers: HookTriggers::beforeStep(),
    )

    // Hook 2: After each step — calculate duration
    ->addHook(
        hook: new CallableHook(function (HookContext $ctx) use (&$timings): HookContext {
            $step = $ctx->state()->stepCount();
            $started = $timings[$step] ?? null;
            $duration = $started ? round((microtime(true) - $started) * 1000) : 0;
            $tokens = $ctx->state()->usage()->total();
            echo "[AfterStep]  Step {$step} completed in {$duration}ms (total tokens: {$tokens})\n";
            return $ctx;
        }),
        triggers: HookTriggers::afterStep(),
    )

    // Hook 3: Before tool use — log which tool is about to run
    ->addHook(
        hook: new CallableHook(function (HookContext $ctx): HookContext {
            $toolName = $ctx->toolCall()?->name() ?? 'unknown';
            echo "[BeforeTool] About to execute: {$toolName}\n";
            return $ctx;
        }),
        triggers: HookTriggers::beforeToolUse(),
    )

    // Hook 4: After tool use — log tool result status
    ->addHook(
        hook: new CallableHook(function (HookContext $ctx): HookContext {
            $exec = $ctx->toolExecution();
            if ($exec !== null) {
                $status = $exec->wasBlocked() ? 'BLOCKED' : 'OK';
                echo "[AfterTool]  {$exec->name()} -> {$status}\n";
            }
            return $ctx;
        }),
        triggers: HookTriggers::afterToolUse(),
    )

    // Hook 5: On stop — final summary
    ->addHook(
        hook: new CallableHook(function (HookContext $ctx): HookContext {
            $state = $ctx->state();
            echo "[OnStop]     Agent stopping after {$state->stepCount()} steps\n";
            return $ctx;
        }),
        triggers: HookTriggers::onStop(),
    )

    ->build();

// Run the agent
$state = AgentState::empty()->withUserMessage(
    'What is the current date? Use bash to find out. Be concise.'
);

echo "=== Agent Execution with Hooks ===\n\n";
$finalState = $agent->execute($state);

echo "\n=== Result ===\n";
$response = $finalState->currentStep()?->outputMessages()->toString() ?? 'No response';
echo "Answer: {$response}\n";
?>
```
