---
title: 'Troubleshooting'
description: 'Common issues and solutions for the Instructor HTTP client API.'
---

This guide covers common issues you may encounter when using the Instructor HTTP client and their solutions.

## Connection Issues

### SSL/TLS Certificate Problems

If you encounter SSL certificate errors:

```php
// Disable SSL verification for testing (NOT recommended for production)
$client = HttpClient::builder()
    ->withOptions(['verify' => false])
    ->build();
```

For production environments, ensure proper CA certificates are installed:

```php
$client = HttpClient::builder()
    ->withOptions(['verify' => '/path/to/cacert.pem'])
    ->build();
```

### Timeout Issues

Configure appropriate timeouts for your use case:

```php
$client = HttpClient::builder()
    ->withOptions([
        'timeout' => 30,        // Request timeout in seconds
        'connect_timeout' => 5, // Connection timeout in seconds
    ])
    ->build();
```

For streaming requests that may take longer:

```php
$client = HttpClient::builder()
    ->withOptions([
        'timeout' => 300,       // 5 minutes for LLM responses
        'read_timeout' => 60,   // Per-chunk read timeout
    ])
    ->build();
```

### Proxy Configuration

If your environment requires proxy settings:

```php
$client = HttpClient::builder()
    ->withOptions([
        'proxy' => 'http://proxy.example.com:8080',
        'proxy_auth' => ['username', 'password'],
    ])
    ->build();
```

## Streaming Issues

### Incomplete Streaming Responses

If streaming responses are incomplete or cut off:

1. Check server-side configuration for streaming support
2. Verify timeout settings allow for long-running streams
3. Ensure middleware doesn't buffer the entire response

```php
// Proper streaming configuration
$response = $client
    ->withRequest($request->withOptions(['stream' => true]))
    ->stream();

foreach ($response as $chunk) {
    // Process immediately, don't accumulate
    echo $chunk;
    flush(); // Force output
}
```

### Memory Issues with Large Responses

For large responses that consume too much memory:

```php
// Use streaming to process data incrementally
$totalSize = 0;
foreach ($client->withRequest($request)->stream() as $chunk) {
    $totalSize += strlen($chunk);

    // Process chunk immediately
    processChunk($chunk);

    // Optional: Monitor memory usage
    if (memory_get_usage() > 50 * 1024 * 1024) { // 50MB limit
        throw new RuntimeException('Memory limit exceeded');
    }
}
```

## Authentication Issues

### API Key Problems

Verify API key configuration:

```php
// Correct header format
$request = $request->withHeaders([
    'Authorization' => 'Bearer ' . $apiKey,
    'Content-Type' => 'application/json',
]);

// Check for common mistakes
if (empty($apiKey)) {
    throw new InvalidArgumentException('API key is required');
}

if (strpos($apiKey, 'Bearer ') === 0) {
    throw new InvalidArgumentException('Do not include "Bearer " in the API key');
}
```

### Token Refresh Issues

For OAuth or other token-based authentication:

```php
class TokenRefreshMiddleware implements HttpMiddleware
{
    public function handle(HttpRequest $request, CanHandleHttpRequest $next): HttpResponse
    {
        $response = $next->handle($request);

        // Handle token expiration
        if ($response->statusCode() === 401) {
            $newToken = $this->refreshToken();
            $request = $request->withHeader('Authorization', 'Bearer ' . $newToken);
            $response = $next->handle($request);
        }

        return $response;
    }
}
```

## Performance Issues

### Slow Requests

Optimize request performance:

```php
// Enable HTTP/2 if available
$client = HttpClient::builder()
    ->withOptions([
        'version' => '2.0',
        'force_resolve' => true,
    ])
    ->build();

// Use connection pooling for multiple requests
$requests = HttpRequestList::of($request1, $request2, $request3);
$responses = $client->pool($requests, maxConcurrent: 3);
```

### High Memory Usage

Monitor and optimize memory usage:

```php
// Use generators for large datasets
function processLargeResponse($client, $request): \Generator
{
    foreach ($client->withRequest($request)->stream() as $chunk) {
        yield processChunk($chunk);
    }
}

// Process without storing in memory
foreach (processLargeResponse($client, $request) as $processedData) {
    // Handle processed data
}
```

## Debugging

### Enable Debug Logging

Add middleware to log requests and responses:

```php
class DebugLoggingMiddleware implements HttpMiddleware
{
    public function handle(HttpRequest $request, CanHandleHttpRequest $next): HttpResponse
    {
        $startTime = microtime(true);

        error_log("Request: {$request->method()} {$request->url()}");
        error_log("Headers: " . json_encode($request->headers()));

        $response = $next->handle($request);

        $duration = microtime(true) - $startTime;
        error_log("Response: {$response->statusCode()} ({$duration}s)");

        return $response;
    }
}

$client = $client->withMiddleware(new DebugLoggingMiddleware());
```

### Inspect Raw HTTP Traffic

Use tools like Wireshark, tcpdump, or proxy tools to inspect network traffic:

```bash
# Using curl to test the same request
curl -v -X POST "https://api.example.com/endpoint" \
     -H "Authorization: Bearer your-token" \
     -H "Content-Type: application/json" \
     -d '{"key": "value"}'
```

## Error Handling

### Proper Exception Handling

Handle different types of errors appropriately:

```php
try {
    $response = $client->withRequest($request)->get();

    if (!$response->isSuccess()) {
        throw new HttpException(
            "HTTP {$response->statusCode()}: {$response->body()}",
            $response->statusCode()
        );
    }

    return $response->body();

} catch (ConnectException $e) {
    // Network connectivity issues
    throw new ServiceUnavailableException('Service temporarily unavailable');

} catch (TimeoutException $e) {
    // Request timeout
    throw new RequestTimeoutException('Request timed out');

} catch (HttpException $e) {
    // HTTP error responses
    if ($e->getCode() >= 500) {
        // Server errors - might be worth retrying
        throw new ServiceUnavailableException('Server error');
    } else {
        // Client errors - fix the request
        throw new BadRequestException('Invalid request: ' . $e->getMessage());
    }
}
```

### Retry Logic

Implement exponential backoff for transient failures:

```php
class RetryMiddleware implements HttpMiddleware
{
    public function handle(HttpRequest $request, CanHandleHttpRequest $next): HttpResponse
    {
        $maxAttempts = 3;
        $baseDelay = 1; // seconds

        for ($attempt = 1; $attempt <= $maxAttempts; $attempt++) {
            try {
                $response = $next->handle($request);

                // Don't retry client errors (4xx)
                if ($response->statusCode() < 500) {
                    return $response;
                }

                if ($attempt === $maxAttempts) {
                    return $response; // Last attempt, return as-is
                }

            } catch (ConnectException|TimeoutException $e) {
                if ($attempt === $maxAttempts) {
                    throw $e; // Last attempt, re-throw
                }
            }

            // Exponential backoff
            $delay = $baseDelay * (2 ** ($attempt - 1));
            sleep($delay);
        }

        return $response;
    }
}
```

## Environment-Specific Issues

### Laravel Integration

Common Laravel-specific issues:

```php
// Ensure proper service provider registration
// In config/app.php
'providers' => [
    // ...
    Cognesy\Http\Laravel\HttpServiceProvider::class,
];

// Check for conflicts with Laravel's HTTP client
use Cognesy\Http\HttpClient as InstructorHttpClient;
use Illuminate\Support\Facades\Http as LaravelHttp;
```

### Symfony Integration

Symfony-specific considerations:

```php
// Check bundle configuration
// In config/bundles.php
return [
    // ...
    Cognesy\Http\Symfony\HttpBundle::class => ['all' => true],
];
```

## Common Error Messages

### "Class not found" Errors

Ensure proper autoloading:

```bash
composer dump-autoload
```

Check namespace imports:

```php
use Cognesy\Http\HttpClient;
use Cognesy\Http\Data\HttpRequest;
```

### "Driver not found" Errors

Install required HTTP client library:

```bash
# For Guzzle
composer require guzzlehttp/guzzle

# For Symfony
composer require symfony/http-client
```

### "Invalid response format" Errors

Verify response content type and parsing:

```php
$response = $client->withRequest($request)->get();

// Check content type
$contentType = $response->header('Content-Type');
if (strpos($contentType, 'application/json') === false) {
    throw new InvalidResponseException('Expected JSON response');
}

// Parse JSON safely
$data = json_decode($response->body(), true);
if (json_last_error() !== JSON_ERROR_NONE) {
    throw new InvalidResponseException('Invalid JSON: ' . json_last_error_msg());
}
```

## Getting Help

If you continue to experience issues:

1. Check the [GitHub Issues](https://github.com/cognesy/instructor-php/issues) for similar problems
2. Enable debug logging to gather more information
3. Create a minimal reproduction case
4. Include PHP version, library versions, and error messages when reporting issues

Remember to never include sensitive information like API keys in debug logs or issue reports.